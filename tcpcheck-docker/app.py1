from flask import Flask, request, jsonify
import socket
import dns.resolver
import ssl
import http.client

app = Flask(__name__)

def dns_resolution(domain):
    try:
        resolver = dns.resolver.Resolver()
        cname = None
        ip_addresses = []
        cname_answers = resolver.resolve(domain, 'CNAME', raise_on_no_answer=False)
        if cname_answers.rrset:
            cname = cname_answers[0].to_text()
        
        ip_answers = resolver.resolve(domain, 'A', raise_on_no_answer=False)
        for answer in ip_answers:
            ip_addresses.append(answer.to_text())
        
        return {'cname': cname, 'ips': ip_addresses}, None
    except Exception as e:
        return None, str(e)

def tcp_connection(ip_address, port, timeout):
    try:
        sock = socket.create_connection((ip_address, port), timeout=timeout)
        sock.close()
        return 'TCP connection successful', None
    except (socket.timeout, socket.error) as e:
        return 'TCP connection failed', str(e)

def http_connection(domain, port, timeout, protocol):
    try:
        conn = http.client.HTTPSConnection(domain, port, timeout=timeout, context=ssl.create_default_context())
        conn.request("HEAD", "/")
        response = conn.getresponse()
        conn.close()
        return 'HTTP connection successful', None
    except ssl.SSLError as e:
        return 'SSL connection failed', str(e)
    except Exception as e:
        return 'HTTP connection failed', str(e)

@app.route('/check_connection', methods=['GET'])
def check_connection():
    port = request.args.get('port')
    domain = request.args.get('domain')
    timeout = request.args.get('timeout', default=5, type=float)

    if not port or not domain:
        return jsonify({'error': 'Port number and domain are required parameters'}), 400

    dns_result, dns_error = dns_resolution(domain)
    if dns_error:
        return jsonify({'error': f'DNS resolution failed: {dns_error}'}), 500

    ip_address = dns_result['ips'][0] if dns_result['ips'] else None
    if not ip_address:
        return jsonify({'error': 'No IP addresses found for domain'}), 500

    message, tcp_error = tcp_connection(ip_address, int(port), timeout)
    if tcp_error:
        return jsonify({'message': message, 'dns_result': dns_result, 'error': tcp_error}), 500

    return jsonify({'message': message, 'dns_result': dns_result}), 200

@app.route('/check_http_connection', methods=['GET'])
def check_http_connection():
    protocol = request.args.get('protocol', 'https')
    domain = request.args.get('domain')
    timeout = request.args.get('timeout', default=5, type=float)

    if not domain:
        return jsonify({'error': 'Domain is a required parameter'}), 400

    port = 443 if protocol == 'https' else 80

    dns_result, dns_error = dns_resolution(domain)
    if dns_error:
        return jsonify({'error': f'DNS resolution failed: {dns_error}'}), 500

    ip_address = dns_result['ips'][0] if dns_result['ips'] else None
    if not ip_address:
        return jsonify({'error': 'No IP addresses found for domain'}), 500

    if protocol == 'https':
        message, connection_error = http_connection(domain, port, timeout, protocol)
    else:
        message, connection_error = tcp_connection(ip_address, port, timeout)

    if connection_error:
        return jsonify({'message': message, 'dns_result': dns_result, 'error': connection_error}), 500

    return jsonify({'message': message, 'dns_result': dns_result}), 200

if __name__ == '__main__':
    app.run(debug=True, port=8080)

